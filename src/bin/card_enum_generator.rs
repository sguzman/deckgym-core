use std::{fs::File, io::Read};

use clap::Parser;

use deckgym::types::{Ability, Attack, Card, EnergyType, TrainerCard};
use indexmap::IndexMap;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Flag to generate the database.rs instead. card_ids.rs is generated by default.
    #[arg(long)]
    database: bool,
}

/// A CLI program to generate card_ids.rs and database.rs from the database.json file.
fn main() {
    let args = Args::parse();

    // Read the JSON file into Card structs
    let mut file = File::open("./database.json").expect("database.json should be there");
    let mut json_string = String::new();
    file.read_to_string(&mut json_string)
        .expect("Unable to read string");
    let deserialized_cards: Vec<Card> = serde_json::from_str(&json_string).unwrap();

    // Generate the Enum Names
    let mut card_map: IndexMap<String, Card> = IndexMap::new();
    let mut id_to_enum: IndexMap<String, String> = IndexMap::new();
    let mut numeric_id_to_enum: IndexMap<u16, String> = IndexMap::new();
    for card in deserialized_cards {
        // Remove special characters from the name
        let mut enum_name = (card.get_id() + &card.get_name())
            .replace(" ", "")
            .replace("-", "")
            .replace(".", "")
            .replace("'", "")
            .replace("♀", "F")
            .replace("♂", "M")
            .replace(":", "")
            .replace("é", "e");
        if enum_name.ends_with("ex") {
            enum_name = enum_name[..enum_name.len() - 2].to_string();
            enum_name.push_str("Ex");
        }
        card_map.insert(enum_name.clone(), card.clone());
        id_to_enum.insert(card.get_id().clone(), enum_name.clone());
        if let Card::Trainer(TrainerCard { numeric_id, .. }) = &card {
            numeric_id_to_enum.insert(*numeric_id, enum_name.clone());
        }
    }

    if args.database {
        print_database(&card_map);
    } else {
        print_enums(&card_map, &id_to_enum, &numeric_id_to_enum);
    }
}

fn print_enums(
    card_map: &IndexMap<String, Card>,
    id_to_enum: &IndexMap<String, String>,
    numeric_id_to_enum: &IndexMap<u16, String>,
) {
    println!("// This is code generated from the database.json by card_enum_generator.rs. Do not edit manually.");
    println!();
    println!("use serde::{{Deserialize, Serialize}};");
    println!();
    println!("#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq, Serialize, Deserialize)]");
    println!("pub enum CardId {{");
    for (name, _) in card_map.iter() {
        println!("    {name},");
    }
    println!("}}\n");
    println!();
    println!();
    println!("impl CardId {{");
    println!("    pub fn from_card_id(id: &str) -> Option<Self> {{");
    println!("        match id {{");
    for (id, enum_name) in id_to_enum.iter() {
        println!("            \"{id}\" => Some(CardId::{enum_name}),");
    }
    println!("            _ => None,");
    println!("        }}");
    println!("    }}");
    println!();
    println!("    pub(crate) fn from_numeric_id(id: u16) -> Option<Self> {{");
    println!("        match id {{");
    for (numeric_id, enum_name) in numeric_id_to_enum.iter() {
        println!("            {numeric_id} => Some(CardId::{enum_name}),");
    }
    println!("            _ => None,");
    println!("        }}");
    println!("    }}");
    println!("}}");
}

fn print_database(card_map: &IndexMap<String, Card>) {
    println!("// This is code generated from the database.json by card_enum_generator.rs. Do not edit manually.");
    println!();
    println!("use crate::{{");
    println!("    card_ids::CardId,");
    println!(
        "    types::{{Ability, Attack, Card, EnergyType, PokemonCard, TrainerCard, TrainerType}},"
    );
    println!("}};");
    println!();
    println!("pub fn get_card_by_enum(id: CardId) -> Card {{");
    println!("    match id {{");
    for (enum_name, card) in card_map.iter() {
        print_card(enum_name, card);
    }
    println!("    }}");
    println!("}}");
}

fn print_card(enum_name: &str, card: &Card) {
    match card {
        Card::Pokemon(pokemon_card) => {
            println!("        CardId::{enum_name} => Card::Pokemon(PokemonCard {{");
            println!("            id: \"{}\".to_string(),", pokemon_card.id);
            println!("            name: \"{}\".to_string(),", pokemon_card.name);
            println!("            stage: {},", pokemon_card.stage);
            println!(
                "            evolves_from: {},",
                to_rust_string(&pokemon_card.evolves_from)
            );
            println!("            hp: {},", pokemon_card.hp);
            println!(
                "            energy_type: EnergyType::{},",
                pokemon_card.energy_type
            );
            println!(
                "            ability: {},",
                to_rust_ability(&pokemon_card.ability)
            );
            print_attacks(&pokemon_card.attacks);
            println!(
                "            weakness: {},",
                to_rust_energy(pokemon_card.weakness)
            );
            println!(
                "            retreat_cost: {},",
                to_rust_energy_vec(&pokemon_card.retreat_cost)
            );
            println!(
                "            rarity: \"{}\".to_string(),",
                pokemon_card.rarity
            );
            println!(
                "            booster_pack: \"{}\".to_string(),",
                pokemon_card.booster_pack
            );
            println!("        }}),");
        }
        Card::Trainer(trainer_card) => {
            println!("        CardId::{enum_name} => Card::Trainer(TrainerCard {{");
            println!("            id: \"{}\".to_string(),", trainer_card.id);
            println!("            numeric_id: {},", trainer_card.numeric_id);
            println!("            name: \"{}\".to_string(),", trainer_card.name);
            println!(
                "            effect: \"{}\".to_string(),",
                trainer_card.effect
            );
            println!(
                "            rarity: \"{}\".to_string(),",
                trainer_card.rarity
            );
            println!(
                "            booster_pack: \"{}\".to_string(),",
                trainer_card.booster_pack
            );
            println!(
                "            trainer_card_type: TrainerType::{:?},",
                trainer_card.trainer_card_type
            );
            println!("        }}),");
        }
    }
    // TODO: AttackIds and AbilitiesIds
}

fn print_attacks(attacks: &[Attack]) {
    println!("            attacks: vec![");
    for attack in attacks {
        println!("                Attack {{");
        println!(
            "                    energy_required: {},",
            to_rust_energy_vec(&attack.energy_required)
        );
        println!(
            "                    title: \"{}\".to_string(),",
            attack.title
        );
        println!("                    fixed_damage: {},", attack.fixed_damage);
        println!(
            "                    effect: {},",
            to_rust_string(&attack.effect)
        );
        println!("                }},");
    }
    println!("            ],");
}

fn to_rust_string(string: &Option<String>) -> String {
    match string {
        Some(string) => format!("Some(\"{string}\".to_string())"),
        None => "None".to_string(),
    }
}
fn to_rust_ability(ability: &Option<Ability>) -> String {
    match ability {
        Some(ability) => format!(
            "Some(Ability {{ title: \"{}\".to_string(), effect: \"{}\".to_string() }})",
            ability.title, ability.effect
        ),
        None => "None".to_string(),
    }
}
fn to_rust_energy(energy_type: Option<EnergyType>) -> String {
    match energy_type {
        Some(energy_type) => format!("Some(EnergyType::{energy_type})"),
        None => "None".to_string(),
    }
}
fn to_rust_energy_vec(energy_types: &Vec<EnergyType>) -> String {
    let mut result = "vec![".to_string();
    for energy_type in energy_types {
        result.push_str(&format!("EnergyType::{energy_type},"));
    }
    result.push(']');
    result
}
